package main

import (
	"fmt"
	"math/rand"
	"net"
	"sync"
	"time"
)

const (
	serverAddr   = "127.0.0.1:8800" // Update with your server address
	numDevices   = 100              // Number of devices
	maxSleepTime = 10000              // Maximum sleep time (milliseconds) between message sending
)

var testMessage = []byte{
	0x00, 0x7C, 0xCA, 0xFE, 0x01, 0x33, 0x00, 0x0F, 0x33, 0x35, 0x32, 0x30, 0x39, 0x34, 0x30, 0x38,
	0x31, 0x36, 0x37, 0x32, 0x31, 0x37, 0x39, 0x08, 0x02, 0x00, 0x00, 0x01, 0x6C, 0x32, 0xB4, 0x88,
	0xA0, 0x00, 0x0A, 0x7A, 0x36, 0x7C, 0x1D, 0x30, 0x01, 0x87, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xF1, 0x07, 0x03, 0x01, 0x00, 0x15, 0x00, 0xEF, 0x00, 0x03, 0x42, 0x31, 0x8B, 0xCD, 0x42,
	0xDC, 0xCE, 0x60, 0x64, 0x01, 0xF1, 0x00, 0x00, 0x59, 0xD9, 0x00, 0x00, 0x00, 0x01, 0x6C, 0x32,
	0xB4, 0x8C, 0x88, 0x00, 0x0A, 0x7A, 0x36, 0x7C, 0x1D, 0x30, 0x01, 0x87, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x15, 0x07, 0x03, 0x01, 0x00, 0x15, 0x01, 0xEF, 0x00, 0x03, 0x42, 0x31, 0x95,
	0xCD, 0x42, 0xDC, 0xCE, 0x60, 0x64, 0x01, 0xF1, 0x00, 0x00, 0x59, 0xD9, 0x00, 0x02,
}

func main() {
	rand.Seed(time.Now().UnixNano())

	var wg sync.WaitGroup
	wg.Add(numDevices)

	for i := 0; i < numDevices; i++ {
		go func(deviceID int) {
			defer wg.Done()

			// Connect to the UDP server
			conn, err := net.Dial("udp", serverAddr)
			if err != nil {
				fmt.Printf("Error connecting to server: %v\n", err)
				return
			}
			defer conn.Close()

			// Generate and send test message for the device
			if err := sendMessage(conn, testMessage); err != nil {
				fmt.Printf("Error sending test message for device %d: %v\n", deviceID, err)
				return
			}

			fmt.Printf("Sent test message from device %d\n", deviceID)
		}(i)
	}

	// Wait for all goroutines to finish
	wg.Wait()
}

func sendMessage(conn net.Conn, message []byte) error {
	// Simulate network latency
	sleepTime := time.Duration(rand.Intn(maxSleepTime)) * time.Millisecond
	time.Sleep(sleepTime)

	// Send the message to the server
	_, err := conn.Write(message)
	return err
}
